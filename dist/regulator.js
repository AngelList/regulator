// Generated by CoffeeScript 1.9.3
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define(factory);
    } else {
      return root.Regulator = factory();
    }
  })(this, function() {
    var Regulator, elementsWithAttribute, hasAttribute, isElement, regulatorCount;
    regulatorCount = 0;
    isElement = function(object) {
      if (typeof HTMLElement === 'object') {
        return object instanceof HTMLElement;
      } else {
        return object && typeof object === 'object' && object !== null && object.nodeType === 1 && typeof object.nodeName === 'string';
      }
    };
    elementsWithAttribute = function(attribute, scope) {
      var el, i, len, ref, results;
      if (!(isElement(scope) || scope.nodeType === 9)) {
        return [];
      }
      if (scope.querySelectorAll != null) {
        return scope.querySelectorAll("[" + attribute + "]");
      } else {
        ref = scope.getElementsByTagName('*');
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          el = ref[i];
          if (el.getAttribute(attribute) != null) {
            results.push(el);
          }
        }
        return results;
      }
    };
    hasAttribute = function(el, attribute) {
      if (el.hasAttribute != null) {
        return el.hasAttribute(attribute);
      } else {
        return typeof el[attribute] !== 'undefined';
      }
    };

    /**
     * @typedef {Object} Regulator.Controller
     *
     * @description
     * An object returned by a {@link Regulator.Strategy} implementation, which becomes associated with a component on the
     * page. Controllers are accessible any time through {@link Regulator#withController} or {@link Regulator#initialize}.
     */

    /**
     * @callback Regulator.Strategy
     *
     * @description
     * An initialization strategy for your components. You're encouraged to structure your application such that the
     * name uniquely describes how to initialize the component.
     *
     * @example
     * new Regulator(function (name, el) {
     *   initializer = require('components/' + name);
     *   return initializer(el);
     * }).observe();
     * // Adding "<div data-rc='foo' />" to the DOM would cause this function to be invoked with name "foo".
     *
     * @param {String} name The name of the component being initialized, i.e. the value of the <code>data-rc</code>
     *   attribute.
     * @param {Element} element The root element of the component being initialized, i.e. the element with a
     *   <code>data-rc</code> attribute.
     * @return {Promise|Regulator.Controller} A controller object to associate with the component, which will be globally
     *   available through the {@link Regulator#initialize} and {@link Regulator#withController} functions. May also
     *   return a <code>Promise</code> object if you wish to build the controller asynchronously.
     */

    /**
     * @callback Regulator.ControllerCallback
     *
     * @description
     * A callback function for {@link Regulator#withController}.
     *
     * @param {Regulator.Controller} controller The controller for a component.
     */

    /**
     * @class Regulator
     *
     * @param {Regulator.Strategy} strategy The function to initialize your components.
     * @param {Object} [options]
     * @param {String} [options.attribute='data-rc'] The attribute to denote the root of a component in the DOM.
     * @param {Number} [options.throttle=200] When observing the DOM for changes with <code>MutationObserver</code>,
     *   the minimum interval (in milliseconds) between successive scans.
     * @param {Number} [options.poll=1000] The interval (in milliseconds) to poll the DOM for changes if
     *   <code>MutationObserver</code> is not available.
     * @param {Element} [options.root=window.document.body] The root element to scan for components. Elements outside this
     *   root will be ignored by {@link Regulator#scan} and {@link Regulator#observe}.
     * @param {Function} [options.Promise=window.Promise] The {@link https://promisesaplus.com/|Promises/A+}
     *   implementation to use.
     * @param {Function} [options.MutationObserver=window.MutationObserver] The
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver|MutationObserver} implementation to use
     *   when invoking {@link Regulator#observe}. If no implementation is provided, a polling fallback is used.
     */
    return Regulator = (function() {
      function Regulator(strategy, options) {
        var k, v;
        if (options == null) {
          options = {};
        }
        this.disconnect = bind(this.disconnect, this);
        this.withController = bind(this.withController, this);
        this.observe = bind(this.observe, this);
        this.scan = bind(this.scan, this);
        this.initialize = bind(this.initialize, this);
        if (typeof strategy !== 'function') {
          throw new TypeError('invalid initialization function');
        }
        this._options = {
          attribute: 'data-rc',
          throttle: 200,
          poll: 1000,
          root: window.document.body,
          Promise: window.Promise,
          MutationObserver: window.MutationObserver
        };
        for (k in options) {
          if (!hasProp.call(options, k)) continue;
          v = options[k];
          this._options[k] = v;
        }
        this._instanceId = regulatorCount++;
        this._strategy = strategy;
        if (!isElement(this._options.root)) {
          throw new Error('options.root must be an HTML element (document.body may not be defined yet?)');
        }
        if (this._options.Promise == null) {
          throw new Error('options.Promise is not defined');
        }
      }


      /**
       * @function Regulator#initialize
       *
       * @description
       * Invoke our {@link Regulator.Strategy} callback to initialize a component.
       *
       * @param {Element} element The root of a component on the page. Must have a non-empty <code>data-rc</code>
       *   attribute (or whatever attribute you specified when creating the {@link Regulator}).
       * @return {Promise} A promise resolving to the {@link Regulator.Controller} associated with the component.
       */

      Regulator.prototype.initialize = function(element) {
        var name;
        if (!hasAttribute(element, this._options.attribute)) {
          throw new Error("Element must have a " + this._options.attribute + " attribute");
        }
        element._regulatorControllers || (element._regulatorControllers = {});
        if (element._regulatorControllers[this._instanceId] == null) {
          name = element.getAttribute(this._options.attribute);
          element._regulatorControllers[this._instanceId] = new this._options.Promise((function(_this) {
            return function(resolve) {
              return resolve(_this._strategy(name, element));
            };
          })(this));
        }
        return element._regulatorControllers[this._instanceId];
      };


      /**
       * @function Regulator#scan
       *
       * @description
       * Immediately initialize any uninitialized components on the page.
       *
       * @return {Promise} A promise which resolves when all components have been initialized.
       */

      Regulator.prototype.scan = function() {
        var el;
        return this._options.Promise.all((function() {
          var i, len, ref, results;
          ref = elementsWithAttribute(this._options.attribute, this._options.root);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            el = ref[i];
            results.push(this.initialize(el));
          }
          return results;
        }).call(this));
      };


      /**
       * @function Regulator#observe
       *
       * @description
       * Watch the page for changes, and initialize components as they're added.
       *
       * @return {Regulator} This {@link Regulator} instance.
       */

      Regulator.prototype.observe = function() {
        var handleMutation, throttledScan;
        throttledScan = ((function(_this) {
          return function(func, wait) {
            var _now, later, previous, timeout;
            _now = function() {
              return new Date().getTime();
            };
            timeout = null;
            previous = 0;
            later = function() {
              previous = _now();
              timeout = null;
              return func();
            };
            return function() {
              var now, remaining;
              now = _now();
              remaining = wait - (now - previous);
              if (remaining <= 0 || remaining > wait) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                return func();
              } else {
                if (!timeout) {
                  return timeout = setTimeout(later, remaining);
                }
              }
            };
          };
        })(this))(((function(_this) {
          return function() {
            return _this.scan();
          };
        })(this)), this._options.throttle);
        if (this._options.MutationObserver != null) {
          if (this._observer == null) {
            this.scan();
            handleMutation = (function(_this) {
              return function(records) {
                var addedNode, broken, i, len, record, results;
                broken = false;
                results = [];
                for (i = 0, len = records.length; i < len; i++) {
                  record = records[i];
                  if (!broken) {
                    results.push((function() {
                      var j, len1, ref, results1;
                      ref = record.addedNodes;
                      results1 = [];
                      for (j = 0, len1 = ref.length; j < len1; j++) {
                        addedNode = ref[j];
                        if (hasAttribute(addedNode, this._options.attribute) || elementsWithAttribute(this._options.attribute, addedNode).length > 0) {
                          throttledScan();
                          broken = true;
                          break;
                        } else {
                          results1.push(void 0);
                        }
                      }
                      return results1;
                    }).call(_this));
                  } else {
                    results.push(void 0);
                  }
                }
                return results;
              };
            })(this);
            this._observer = new this._options.MutationObserver(handleMutation);
            this._observer.observe(this._options.root, {
              childList: true,
              subtree: true
            });
          }
        } else if (this._options.poll) {
          if (!this._interval) {
            this.scan();
            this._interval = setInterval(((function(_this) {
              return function() {
                return _this.scan();
              };
            })(this)), this._options.poll);
          }
        } else {
          throw new Error('options.MutationObserver or options.poll must be set');
        }
        return this;
      };


      /**
       * @function Regulator#withController
       *
       * @description
       * Initialize the given components, and invoke the callback with each of their
       *   {@link Regulator.Controller|controllers}.
       *
       * @param {Element|Element[]} elements The root element(s) of the component(s) to be initialized.
       * @param {Regulator.ControllerCallback} callback The callback to invoke with the controller for each element.
       */

      Regulator.prototype.withController = function(elements, callback) {
        var el;
        if (isElement(elements)) {
          elements = [elements];
        }
        return this._options.Promise.all((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = elements.length; i < len; i++) {
            el = elements[i];
            results.push(this.initialize(el).then(callback));
          }
          return results;
        }).call(this));
      };


      /**
       * @function Regulator#disconnect
       *
       * @description
       * Stop watching the page for changes after a call to {@link Regulator#observe}.
       *
       * @return {Regulator} This {@link Regulator} instance.
       */

      Regulator.prototype.disconnect = function() {
        var ref;
        if ((ref = this._observer) != null) {
          ref.disconnect();
        }
        this._observer = void 0;
        if (this._interval) {
          clearInterval(this._interval);
          this._interval = void 0;
        }
        return this;
      };

      return Regulator;

    })();
  });

}).call(this);
