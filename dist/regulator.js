// Generated by CoffeeScript 1.9.3
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define(factory);
    } else {
      return root.Regulator = factory();
    }
  })(this, function() {
    var Regulator, elementsWithAttribute, hasAttribute, isElement, regulatorCount;
    regulatorCount = 0;
    isElement = function(object) {
      if (typeof HTMLElement === 'object') {
        return object instanceof HTMLElement;
      } else {
        return object && typeof object === 'object' && object !== null && object.nodeType === 1 && typeof object.nodeName === 'string';
      }
    };
    elementsWithAttribute = function(attribute, scope) {
      var el, i, len, ref, results;
      if (!(isElement(scope) || scope.nodeType === 9)) {
        return [];
      }
      if (scope.querySelectorAll != null) {
        return scope.querySelectorAll("[" + attribute + "]");
      } else {
        ref = scope.getElementsByTagName('*');
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          el = ref[i];
          if (el.getAttribute(attribute) != null) {
            results.push(el);
          }
        }
        return results;
      }
    };
    hasAttribute = function(el, attribute) {
      if (el.hasAttribute != null) {
        return el.hasAttribute(attribute);
      } else {
        return typeof el[attribute] !== 'undefined';
      }
    };
    return Regulator = (function() {

      /**
       * An initialization function for your components. Components are marked by the presence of a `data-wt` attribute
       * (or whatever attribute you've configured for your `Regulator` instance), and their name is the value of this
       * attribute.
       *
       * You're encouraged to structure your application such that the name uniquely describes how to initialize the
       * component.
       *
       * @example
       *   new Regulator(function (name, el) {
       *     initializer = require('components/' + name);
       *     return initializer(el);
       *   }).observe();
       *   // Adding `<div data-wt='foo' />` to the DOM would cause this function to be invoked with name 'foo'.
       *
       * @callback initializeCallback
       * @param {string} name - The name of the component being initialized, i.e. the value of the data-wt attribute.
       * @param {Element} el - The root element of the component being initialized, i.e. the element with a data-wt
       *   attribute.
       * @return {Promise|object} A controller object for this component, or a promise resolving with that object. This
       *   controller will be returned (as a promise) from the `initialize` method on your regulator instance, and passed
       *   to the teardown callback that you specify.
       */

      /**
       * @param {initializeCallback} initialize - The function to initialize your components
       */
      function Regulator(initialize, options) {
        var k, v;
        if (options == null) {
          options = {};
        }
        this.disconnect = bind(this.disconnect, this);
        this.withController = bind(this.withController, this);
        this.observe = bind(this.observe, this);
        this.scan = bind(this.scan, this);
        this.initialize = bind(this.initialize, this);
        if (typeof initialize !== 'function') {
          throw new TypeError('invalid initialization function');
        }
        this._options = {
          attribute: 'data-rc',
          throttle: 200,
          poll: 1000,
          root: window.document.body,
          Promise: window.Promise,
          MutationObserver: window.MutationObserver
        };
        for (k in options) {
          if (!hasProp.call(options, k)) continue;
          v = options[k];
          this._options[k] = v;
        }
        this._instanceId = regulatorCount++;
        this._initialize = initialize;
        if (!isElement(this._options.root)) {
          throw new Error('options.root must be an HTML element (document.body may not be defined yet?)');
        }
        if (this._options.Promise == null) {
          throw new Error('options.Promise is not defined');
        }
      }

      Regulator.prototype.initialize = function(el) {
        var name;
        if (!hasAttribute(el, this._options.attribute)) {
          throw new Error("Element must have a " + this._options.attribute + " attribute");
        }
        el._regulatorControllers || (el._regulatorControllers = {});
        if (el._regulatorControllers[this._instanceId] == null) {
          name = el.getAttribute(this._options.attribute);
          el._regulatorControllers[this._instanceId] = new this._options.Promise((function(_this) {
            return function(resolve) {
              return resolve(_this._initialize(name, el));
            };
          })(this));
        }
        return el._regulatorControllers[this._instanceId];
      };

      Regulator.prototype.scan = function() {
        var el;
        return this._options.Promise.all((function() {
          var i, len, ref, results;
          ref = elementsWithAttribute(this._options.attribute, this._options.root);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            el = ref[i];
            results.push(this.initialize(el));
          }
          return results;
        }).call(this));
      };

      Regulator.prototype.observe = function() {
        var handleMutation, throttledScan;
        throttledScan = ((function(_this) {
          return function(func, wait) {
            var _now, later, previous, timeout;
            _now = function() {
              return new Date().getTime();
            };
            timeout = null;
            previous = 0;
            later = function() {
              previous = _now();
              timeout = null;
              return func();
            };
            return function() {
              var now, remaining;
              now = _now();
              remaining = wait - (now - previous);
              if (remaining <= 0 || remaining > wait) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                return func();
              } else {
                if (!timeout) {
                  return timeout = setTimeout(later, remaining);
                }
              }
            };
          };
        })(this))(((function(_this) {
          return function() {
            return _this.scan();
          };
        })(this)), this._options.throttle);
        if (this._options.MutationObserver != null) {
          if (this._observer == null) {
            this.scan();
            handleMutation = (function(_this) {
              return function(records) {
                var addedNode, broken, i, len, record, results;
                broken = false;
                results = [];
                for (i = 0, len = records.length; i < len; i++) {
                  record = records[i];
                  if (!broken) {
                    results.push((function() {
                      var j, len1, ref, results1;
                      ref = record.addedNodes;
                      results1 = [];
                      for (j = 0, len1 = ref.length; j < len1; j++) {
                        addedNode = ref[j];
                        if (hasAttribute(addedNode, this._options.attribute) || elementsWithAttribute(this._options.attribute, addedNode).length > 0) {
                          throttledScan();
                          broken = true;
                          break;
                        } else {
                          results1.push(void 0);
                        }
                      }
                      return results1;
                    }).call(_this));
                  } else {
                    results.push(void 0);
                  }
                }
                return results;
              };
            })(this);
            this._observer = new this._options.MutationObserver(handleMutation);
            this._observer.observe(this._options.root, {
              childList: true,
              subtree: true
            });
          }
        } else if (this._options.poll) {
          if (!this._interval) {
            this.scan();
            this._interval = setInterval(((function(_this) {
              return function() {
                return _this.scan();
              };
            })(this)), this._options.poll);
          }
        } else {
          throw new Error('options.MutationObserver or options.poll must be set');
        }
        return this;
      };

      Regulator.prototype.withController = function(elements, callback) {
        var el;
        if (isElement(elements)) {
          elements = [elements];
        }
        return this._options.Promise.all((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = elements.length; i < len; i++) {
            el = elements[i];
            results.push(this.initialize(el).then(callback));
          }
          return results;
        }).call(this));
      };

      Regulator.prototype.disconnect = function() {
        var ref;
        if ((ref = this._observer) != null) {
          ref.disconnect();
        }
        this._observer = void 0;
        if (this._interval) {
          clearInterval(this._interval);
          return this._interval = void 0;
        }
      };

      return Regulator;

    })();
  });

}).call(this);
