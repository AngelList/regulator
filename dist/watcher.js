// Generated by CoffeeScript 1.8.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty;

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define(factory);
    } else {
      return root.Watcher = factory();
    }
  })(this, function() {
    var Watcher, elementsWithAttribute, hasAttribute, watcherCount;
    watcherCount = 0;
    elementsWithAttribute = function(attribute, scope) {
      var el, _i, _len, _ref, _results;
      if (scope == null) {
        scope = document;
      }
      if (scope.querySelectorAll != null) {
        return scope.querySelectorAll("[" + attribute + "]");
      } else {
        _ref = scope.getElementsByTagName('*');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          if (el.getAttribute(attribute) != null) {
            _results.push(el);
          }
        }
        return _results;
      }
    };
    hasAttribute = function(el, attribute) {
      if (el.hasAttribute != null) {
        return el.hasAttribute(attribute);
      } else {
        return typeof el[attribute] !== 'undefined';
      }
    };
    return Watcher = (function() {
      function Watcher(getInitializer, options) {
        var k, v;
        if (options == null) {
          options = {};
        }
        this._throttledScan = __bind(this._throttledScan, this);
        this._handleMutation = __bind(this._handleMutation, this);
        this.disconnect = __bind(this.disconnect, this);
        this.observe = __bind(this.observe, this);
        this.scan = __bind(this.scan, this);
        this.initialize = __bind(this.initialize, this);
        this._options = {
          attribute: 'data-watcher-name',
          throttle: 200,
          promiseShim: Promise,
          mutationObserverShim: MutationObserver
        };
        for (k in options) {
          if (!__hasProp.call(options, k)) continue;
          v = options[k];
          this._options[k] = v;
        }
        this._instanceId = watcherCount++;
        this._initializers = {};
        this._getInitializer = getInitializer;
        if (this._options.promiseShim == null) {
          throw new Error('Promise is not defined. Provide a shim if you need to support older browsers.');
        }
      }

      Watcher.prototype.initialize = function(el) {
        var name, promise, _base;
        if (!hasAttribute(el, this._options.attribute)) {
          throw new Error("Element must have a " + this._options.attribute + " attribute");
        }
        el._watcherControllers || (el._watcherControllers = {});
        if (el._watcherControllers[this._instanceId] == null) {
          name = el.getAttribute(this._options.attribute);
          (_base = this._initializers)[name] || (_base[name] = this._getInitializer(name));
          promise = this._options.promiseShim.resolve(this._initializers[name]).then(function(initializer) {
            return initializer(el);
          });
          el._watcherControllers[this._instanceId] = promise;
          promise["catch"]((function(_this) {
            return function(error) {
              return _this.onError(error, name, el);
            };
          })(this));
          el._watcherControllers[this._instanceId] = promise;
        }
        return el._watcherControllers[this._instanceId];
      };

      Watcher.prototype.scan = function() {
        var el;
        return this._options.promiseShim.all((function() {
          var _i, _len, _ref, _results;
          _ref = elementsWithAttribute(this._options.attribute);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            el = _ref[_i];
            _results.push(this.initialize(el));
          }
          return _results;
        }).call(this));
      };

      Watcher.prototype.observe = function() {
        if (this._options.mutationObserverShim == null) {
          throw new Error('MutationObserver is not defined. Provide a shim if you need to support older browsers');
        }
        if (this._observer == null) {
          this.scan();
          this._observer = new this._options.mutationObserverShim(this._handleMutation);
          this._observer.observe(document.getElementsByTagName('body')[0], {
            childList: true,
            subtree: true
          });
        }
        return this;
      };

      Watcher.prototype.disconnect = function() {
        var _ref;
        if ((_ref = this._observer) != null) {
          _ref.disconnect();
        }
        return this._observer = null;
      };

      Watcher.prototype.onError = function(error, name, el) {
        return setTimeout((function() {
          throw error;
        }), 0);
      };

      Watcher.prototype._handleMutation = function(records) {
        var addedNode, broken, record, _i, _len, _results;
        broken = false;
        _results = [];
        for (_i = 0, _len = records.length; _i < _len; _i++) {
          record = records[_i];
          if (!broken) {
            _results.push((function() {
              var _j, _len1, _ref, _results1;
              _ref = record.addedNodes;
              _results1 = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                addedNode = _ref[_j];
                if (hasAttribute(addedNode, this._options.attribute) || elementsWithAttribute(this._options.attribute, addedNode).length > 0) {
                  this._throttledScan();
                  broken = true;
                  break;
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Watcher.prototype._throttledScan = function() {
        this._throttledScanFn || (this._throttledScanFn = ((function(_this) {
          return function(func, wait) {
            var later, previous, timeout, _now;
            _now = Date.now || function() {
              return new Date().getTime();
            };
            timeout = null;
            previous = 0;
            later = function() {
              previous = _now();
              timeout = null;
              return func();
            };
            return function() {
              var now, remaining;
              now = _now();
              remaining = wait - (now - previous);
              if (remaining <= 0 || remaining > wait) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                return func();
              } else {
                if (!timeout) {
                  return timeout = setTimeout(later, remaining);
                }
              }
            };
          };
        })(this))(this.scan, this._options.throttle));
        this._throttledScanFn();
        return this;
      };

      return Watcher;

    })();
  });

}).call(this);
